name: Auto-merge portctl formula PRs

permissions:
  contents: write
  pull-requests: write

on:
  pull_request:
    types: [opened, reopened, synchronize, labeled]

jobs:
  validate-and-merge:
    runs-on: ubuntu-latest
    if: ${{ github.event.pull_request.draft == false }}
    steps:
      - name: Validate PR origin and contents
        id: validate
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let pr = context.payload.pull_request;
            let prNumber = pr && pr.number;

            if (!prNumber) {
              const openPRs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open' });
              openPRs.sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
              let found = null;
              for (const p of openPRs) {
                if (!p.head || !p.head.repo || p.head.repo.full_name !== `${owner}/${repo}`) continue;
                const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: p.number });
                if (!files.some(f => f.filename === 'Formula/portctl.rb')) continue;
                const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: p.number });
                const commitMatches = commits.some(c =>
                  (c.commit && c.commit.message && c.commit.message.includes('chasesaurabh/portctl')) ||
                  (c.author && c.author.login && c.author.login === 'github-actions[bot]')
                );
                if (commitMatches) { found = p; break; }
                if (!found) found = p;
              }
              if (!found) return { prNumber: '', payload: '', sigHex: '' };
              pr = found;
              prNumber = pr.number;
            }

            const body = (pr.body || '').toString();
            console.log('PR body raw: >>>' + body + '<<<');
            const payloadMatch = body.match(/^Automerge-Payload:\s*(.+)$/m);
            const sigMatch = body.match(/^Automerge-Signature:\s*(.+)$/m);
            if (!payloadMatch || !sigMatch) return { prNumber, payload: '', sigHex: '' };

            const rawPayload = payloadMatch[1].trim();
            const rawSig = sigMatch[1].trim();
            const payload = rawPayload.replace(/^"(.+)"$/, '$1');
            const sigHex = rawSig.replace(/^"(.+)"$/, '$1');

            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber });
            if (files.length !== 1 || files[0].filename !== 'Formula/portctl.rb') return { prNumber, payload: '', sigHex: '' };

            const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: prNumber });
            const commitMatches = commits.some(c =>
              (c.commit && c.commit.message && c.commit.message.includes('chasesaurabh/portctl')) ||
              (c.author && c.author.login && c.author.login === 'github-actions[bot]')
            );
            if (!commitMatches) return { prNumber, payload: '', sigHex: '' };

            return { prNumber, payload, sigHex };

      - name: Verify HMAC signature and merge
        env:
          AUTOMERGE_SHARED_SECRET: ${{ secrets.AUTOMERGE_SHARED_SECRET }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          PR_NUMBER: ${{ fromJson(steps.validate.outputs.result).prNumber }}
          PAYLOAD: ${{ fromJson(steps.validate.outputs.result).payload }}
          SIGHEX: ${{ fromJson(steps.validate.outputs.result).sigHex }}
        run: |
          set -euo pipefail
          if [ -z "${AUTOMERGE_SHARED_SECRET:-}" ]; then
            echo "AUTOMERGE_SHARED_SECRET not set, refusing to auto-merge" >&2
            exit 1
          fi

          if [ -z "$PAYLOAD" ] || [ -z "$SIGHEX" ]; then
            echo "No Automerge payload/signature found â€” nothing to do.";
            exit 0
          fi

          CALC_SIG=$(printf "%s" "$PAYLOAD" | openssl dgst -sha256 -hmac "${AUTOMERGE_SHARED_SECRET}" -binary | xxd -p -c 256)
          if [ "$CALC_SIG" != "$SIGHEX" ]; then
            echo "Signature mismatch: expected $SIGHEX computed $CALC_SIG" >&2
            echo "Refusing to merge." >&2
            exit 1
          fi

          PR_JSON=$(curl -s -H "Accept: application/vnd.github+json" -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR_NUMBER}")
          MERGEABLE_STATE=$(echo "$PR_JSON" | python3 -c "import sys, json; print(json.load(sys.stdin).get('mergeable_state'))")
          echo "mergeable_state=$MERGEABLE_STATE"
          if [ "$MERGEABLE_STATE" = "dirty" ] || [ "$MERGEABLE_STATE" = "blocked" ] || [ "$MERGEABLE_STATE" = "unknown" ]; then
            echo "PR not in acceptable mergeable state: $MERGEABLE_STATE" >&2
            exit 1
          fi

          MERGE_RESP=$(curl -s -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR_NUMBER}/merge" \
            -d '{"merge_method":"merge"}')

          MERGED=$(echo "$MERGE_RESP" | python3 -c "import sys, json; print(json.load(sys.stdin).get('merged', False))")
          if [ "$MERGED" != "True" ] && [ "$MERGED" != "true" ]; then
            echo "Merge failed. Response: $MERGE_RESP" >&2
            exit 1
          fi
          echo "Merged PR #${PR_NUMBER} successfully."
