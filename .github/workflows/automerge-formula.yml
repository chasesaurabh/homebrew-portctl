name: Auto-merge portctl formula PRs

permissions:
  contents: write
  pull-requests: write

on:
  pull_request:
    types: [opened, reopened, synchronize, labeled]

jobs:
  validate-and-merge:
    runs-on: ubuntu-latest
    if: ${{ github.event.pull_request.draft == false }}
    steps:
      - name: Validate PR origin and contents
        id: validate
        uses: actions/github-script@v6
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            let pr = context.payload.pull_request;
            let prNumber = pr && pr.number;

            if (prNumber) {
              // If this PR does not touch the formula, skip verification (no-op)
              const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber });
              if (!(files.length === 1 && files[0].filename === 'Formula/portctl.rb')) {
                return { prNumber, payload: '', sigHex: '' };
              }

              // It's a formula PR — extract Automerge lines from the body
              const body = (pr.body || '').toString();
              console.log('PR body raw: >>>' + body + '<<<');
              const payloadMatch = body.match(/^Automerge-Payload:\s*(.+)$/m);
              const sigMatch = body.match(/^Automerge-Signature:\s*(.+)$/m);
              if (!payloadMatch || !sigMatch) {
                throw new Error('Missing Automerge-Payload or Automerge-Signature in PR body.');
              }

              const rawPayload = payloadMatch[1].trim();
              const rawSig = sigMatch[1].trim();
              const payload = rawPayload.replace(/^"(.+)"$/, '$1');
              const sigHex = rawSig.replace(/^"(.+)"$/, '$1');

              const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: prNumber });
              const commitMatches = commits.some(c =>
                (c.commit && c.commit.message && c.commit.message.includes('chasesaurabh/portctl')) ||
                (c.author && c.author.login && c.author.login === 'github-actions[bot]')
              );
              if (!commitMatches) {
                throw new Error('No commit indicates origin from chasesaurabh/portctl or was authored by actions bot.');
              }

              return { prNumber, payload, sigHex };
            }

            // No PR in event payload: fallback to scanning open PRs for a formula update
            const openPRs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open' });
            openPRs.sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
            let found = null;
            for (const p of openPRs) {
              if (!p.head || !p.head.repo || p.head.repo.full_name !== `${owner}/${repo}`) continue;
              const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: p.number });
              if (!files.some(f => f.filename === 'Formula/portctl.rb')) continue;
              const candidateBody = (p.body || '').toString();
              const hasAutomergeLines = /Automerge-Payload:/m.test(candidateBody) && /Automerge-Signature:/m.test(candidateBody);
              if (!hasAutomergeLines) {
                if (!found) found = p; // keep as fallback
                continue;
              }
              const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: p.number });
              const commitMatches = commits.some(c =>
                (c.commit && c.commit.message && c.commit.message.includes('chasesaurabh/portctl')) ||
                (c.author && c.author.login && c.author.login === 'github-actions[bot]')
              );
              if (commitMatches) { found = p; break; }
              if (!found) found = p;
            }
            if (!found) {
              return { prNumber: '', payload: '', sigHex: '' };
            }

            pr = found;
            prNumber = pr.number;
            const body = (pr.body || '').toString();
            const payloadMatch = body.match(/^Automerge-Payload:\s*(.+)$/m);
            const sigMatch = body.match(/^Automerge-Signature:\s*(.+)$/m);
            const rawPayload = payloadMatch ? payloadMatch[1].trim() : '';
            const rawSig = sigMatch ? sigMatch[1].trim() : '';
            const payload = rawPayload.replace(/^"(.+)"$/, '$1');
            const sigHex = rawSig.replace(/^"(.+)"$/, '$1');
            return { prNumber, payload, sigHex };

      - name: Verify HMAC signature and merge
        env:
          AUTOMERGE_SHARED_SECRET: ${{ secrets.AUTOMERGE_SHARED_SECRET }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          PR_NUMBER: ${{ fromJson(steps.validate.outputs.result).prNumber }}
          PAYLOAD: ${{ fromJson(steps.validate.outputs.result).payload }}
          SIGHEX: ${{ fromJson(steps.validate.outputs.result).sigHex }}
        run: |
          set -euo pipefail
          if [ -z "${AUTOMERGE_SHARED_SECRET:-}" ]; then
            echo "AUTOMERGE_SHARED_SECRET not set, refusing to auto-merge" >&2
            exit 1
          fi

          if [ -z "$PAYLOAD" ] || [ -z "$SIGHEX" ]; then
            echo "No Automerge payload/signature found — non-formula PR or validate indicated skip. Nothing to do.";
            exit 0
          fi

          CALC_SIG=$(printf "%s" "$PAYLOAD" | openssl dgst -sha256 -hmac "${AUTOMERGE_SHARED_SECRET}" -binary | xxd -p -c 256)
          if [ "$CALC_SIG" != "$SIGHEX" ]; then
            echo "Signature mismatch: expected $SIGHEX computed $CALC_SIG" >&2
            echo "Refusing to merge." >&2
            exit 1
          fi

          PR_JSON=$(curl -s -H "Accept: application/vnd.github+json" -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR_NUMBER}")
          MERGEABLE_STATE=$(echo "$PR_JSON" | python3 -c "import sys, json; print(json.load(sys.stdin).get('mergeable_state'))")
          echo "mergeable_state=$MERGEABLE_STATE"
          if [ "$MERGEABLE_STATE" = "dirty" ] || [ "$MERGEABLE_STATE" = "blocked" ] || [ "$MERGEABLE_STATE" = "unknown" ]; then
            echo "PR not in acceptable mergeable state: $MERGEABLE_STATE" >&2
            exit 1
          fi

          MERGE_RESP=$(curl -s -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR_NUMBER}/merge" \
            -d '{"merge_method":"merge"}')

          MERGED=$(echo "$MERGE_RESP" | python3 -c "import sys, json; print(json.load(sys.stdin).get('merged', False))")
          if [ "$MERGED" != "True" ] && [ "$MERGED" != "true" ]; then
            echo "Merge failed. Response: $MERGE_RESP" >&2
            exit 1
          fi
          echo "Merged PR #${PR_NUMBER} successfully."
name: Auto-merge portctl formula PRs

permissions:
  contents: write
  pull-requests: write

on:
  pull_request:
    types: [opened, reopened, synchronize, labeled]

jobs:
  validate-and-merge:
    runs-on: ubuntu-latest
    if: ${{ github.event.pull_request.draft == false }}
    steps:
      - name: Validate PR origin and contents
        id: validate
        uses: actions/github-script@v6
        with:
          script: |
            // Defensive validation: throw on error so the job stops and later steps don't try to parse empty outputs
            const pr = context.payload.pull_request;
            if (!pr) {
              throw new Error('No pull_request payload available in context.');
            }

            const prNumber = pr.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const body = (pr.body || "").toString();
            const payloadLine = body.split('\n').find(l => l.startsWith('Automerge-Payload:'));
            const sigLine = body.split('\n').find(l => l.startsWith('Automerge-Signature:'));
            if (!payloadLine || !sigLine) {
              throw new Error('Missing Automerge-Payload or Automerge-Signature in PR body.');
            }

            // Extract and normalize values (strip surrounding quotes if present)
            const rawPayload = payloadLine.split(':').slice(1).join(':').trim();
            const rawSig = sigLine.split(':').slice(1).join(':').trim();
            const payload = rawPayload.replace(/^"(.+)"$/, '$1');
            const sigHex = rawSig.replace(/^"(.+)"$/, '$1');

            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber });
            if (files.length !== 1 || files[0].filename !== 'Formula/portctl.rb') {
              throw new Error(`PR must change exactly Formula/portctl.rb. Files: ${files.map(f=>f.filename).join(', ')}`);
            }

            const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: prNumber });
            const commitMatches = commits.some(c =>
              (c.commit && c.commit.message && c.commit.message.includes('chasesaurabh/portctl')) ||
              (c.author && c.author.login && c.author.login === 'github-actions[bot]')
            );
            if (!commitMatches) {
              throw new Error('No commit indicates origin from chasesaurabh/portctl or was authored by actions bot.');
            }

            return { prNumber, payload, sigHex };

      - name: Verify HMAC signature and merge
        env:
          AUTOMERGE_SHARED_SECRET: ${{ secrets.AUTOMERGE_SHARED_SECRET }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          PR_NUMBER: ${{ fromJson(steps.validate.outputs.result).prNumber }}
          PAYLOAD: ${{ fromJson(steps.validate.outputs.result).payload }}
          SIGHEX: ${{ fromJson(steps.validate.outputs.result).sigHex }}
        run: |
          set -euo pipefail
          if [ -z "${AUTOMERGE_SHARED_SECRET:-}" ]; then
            echo "AUTOMERGE_SHARED_SECRET not set, refusing to auto-merge" >&2
            exit 1
          fi

          if [ -z "$PAYLOAD" ] || [ -z "$SIGHEX" ]; then
            echo "Missing payload or signature outputs" >&2
            exit 1
          fi

          CALC_SIG=$(printf "%s" "$PAYLOAD" | openssl dgst -sha256 -hmac "${AUTOMERGE_SHARED_SECRET}" -binary | xxd -p -c 256)
          if [ "$CALC_SIG" != "$SIGHEX" ]; then
            echo "Signature mismatch: expected $SIGHEX computed $CALC_SIG" >&2
            echo "Refusing to merge." >&2
            exit 1
          fi

          PR_JSON=$(curl -s -H "Accept: application/vnd.github+json" -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR_NUMBER}")
          MERGEABLE_STATE=$(echo "$PR_JSON" | python3 -c "import sys, json; print(json.load(sys.stdin).get('mergeable_state'))")
          echo "mergeable_state=$MERGEABLE_STATE"
          if [ "$MERGEABLE_STATE" = "dirty" ] || [ "$MERGEABLE_STATE" = "blocked" ] || [ "$MERGEABLE_STATE" = "unknown" ]; then
            echo "PR not in acceptable mergeable state: $MERGEABLE_STATE" >&2
            exit 1
          fi

          MERGE_RESP=$(curl -s -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${OWNER}/${REPO}/pulls/${PR_NUMBER}/merge" \
            -d '{"merge_method":"merge"}')

          MERGED=$(echo "$MERGE_RESP" | python3 -c "import sys, json; print(json.load(sys.stdin).get('merged', False))")
          if [ "$MERGED" != "True" ] && [ "$MERGED" != "true" ]; then
            echo "Merge failed. Response: $MERGE_RESP" >&2
            exit 1
          fi
          echo "Merged PR #${PR_NUMBER} successfully."
